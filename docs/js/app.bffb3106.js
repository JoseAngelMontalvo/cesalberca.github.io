(function(e){function t(t){for(var o,a,i=t[0],c=t[1],u=t[2],l=0,p=[];l<i.length;l++)a=i[l],r[a]&&p.push(r[a][0]),r[a]=0;for(o in c)Object.prototype.hasOwnProperty.call(c,o)&&(e[o]=c[o]);m&&m(t);while(p.length)p.shift()();return s.push.apply(s,u||[]),n()}function n(){for(var e,t=0;t<s.length;t++){for(var n=s[t],o=!0,a=1;a<n.length;a++){var i=n[a];0!==r[i]&&(o=!1)}o&&(s.splice(t--,1),e=c(c.s=n[0]))}return e}var o={},a={app:0},r={app:0},s=[];function i(e){return c.p+"js/"+({about:"about",articles:"articles",home:"home",talks:"talks"}[e]||e)+"."+{about:"59b04acc",articles:"ce368b78",home:"3d47771c",talks:"1655e918"}[e]+".js"}function c(t){if(o[t])return o[t].exports;var n=o[t]={i:t,l:!1,exports:{}};return e[t].call(n.exports,n,n.exports,c),n.l=!0,n.exports}c.e=function(e){var t=[],n={articles:1};a[e]?t.push(a[e]):0!==a[e]&&n[e]&&t.push(a[e]=new Promise(function(t,n){for(var o="css/"+({about:"about",articles:"articles",home:"home",talks:"talks"}[e]||e)+"."+{about:"31d6cfe0",articles:"01c9ad5d",home:"31d6cfe0",talks:"31d6cfe0"}[e]+".css",r=c.p+o,s=document.getElementsByTagName("link"),i=0;i<s.length;i++){var u=s[i],l=u.getAttribute("data-href")||u.getAttribute("href");if("stylesheet"===u.rel&&(l===o||l===r))return t()}var p=document.getElementsByTagName("style");for(i=0;i<p.length;i++){u=p[i],l=u.getAttribute("data-href");if(l===o||l===r)return t()}var m=document.createElement("link");m.rel="stylesheet",m.type="text/css",m.onload=t,m.onerror=function(t){var o=t&&t.target&&t.target.src||r,s=new Error("Loading CSS chunk "+e+" failed.\n("+o+")");s.request=o,delete a[e],m.parentNode.removeChild(m),n(s)},m.href=r;var d=document.getElementsByTagName("head")[0];d.appendChild(m)}).then(function(){a[e]=0}));var o=r[e];if(0!==o)if(o)t.push(o[2]);else{var s=new Promise(function(t,n){o=r[e]=[t,n]});t.push(o[2]=s);var u,l=document.createElement("script");l.charset="utf-8",l.timeout=120,c.nc&&l.setAttribute("nonce",c.nc),l.src=i(e),u=function(t){l.onerror=l.onload=null,clearTimeout(p);var n=r[e];if(0!==n){if(n){var o=t&&("load"===t.type?"missing":t.type),a=t&&t.target&&t.target.src,s=new Error("Loading chunk "+e+" failed.\n("+o+": "+a+")");s.type=o,s.request=a,n[1](s)}r[e]=void 0}};var p=setTimeout(function(){u({type:"timeout",target:l})},12e4);l.onerror=l.onload=u,document.head.appendChild(l)}return Promise.all(t)},c.m=e,c.c=o,c.d=function(e,t,n){c.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},c.r=function(e){"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},c.t=function(e,t){if(1&t&&(e=c(e)),8&t)return e;if(4&t&&"object"===typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(c.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var o in e)c.d(n,o,function(t){return e[t]}.bind(null,o));return n},c.n=function(e){var t=e&&e.__esModule?function(){return e["default"]}:function(){return e};return c.d(t,"a",t),t},c.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},c.p="/blog/",c.oe=function(e){throw console.error(e),e};var u=window["webpackJsonp"]=window["webpackJsonp"]||[],l=u.push.bind(u);u.push=t,u=u.slice();for(var p=0;p<u.length;p++)t(u[p]);var m=l;s.push([0,"chunk-vendors"]),n()})({0:function(e,t,n){e.exports=n("cd49")},"091c":function(e,t,n){},"1bb4":function(e,t,n){"use strict";n.d(t,"a",function(){return r});n("a481");var o=n("d225"),a=n("b0b4"),r=function(){function e(t){Object(o["a"])(this,e),this._value=t}return Object(a["a"])(e,[{key:"slug",get:function(){return encodeURIComponent(this._value.toLowerCase()).replace(/%20/g,"+")}},{key:"value",get:function(){return this._value}}],[{key:"fromValue",value:function(t){return new e(t)}}]),e}()},"1d7e":function(e,t,n){},"1f48":function(e,t,n){},"33e6":function(e,t,n){},3507:function(e,t,n){"use strict";n("4f44");var o,a=n("2d7d"),r=n.n(a),s=n("d225"),i=n("b0b4"),c=new r.a([["_theme","Tema"],["_language","Idioma"],["_en","Inglés"],["_es","Español"],["_dark","Oscuro"],["_light","Claro"],["home_title","Inicio"],["home_recentArticles","Artículos recientes"],["article_title","Artículos"],["about_title","Acerca de mí"],["about_description","I'm a young programmer very interested in good practices, architecture, testing and SOLID principles. I work at [Autentia](https://www.autentia.com/) as a frontend developer (Vue, React, TypeScript, JavaScript, HTML, CSS, etc) although I have worked a bit in Java and Android. I'm continuously on the lookout for things to read, learn and [share](https://www.adictosaltrabajo.com/author/calberca/). I've talked at [JSDay Madrid](https://www.youtube.com/watch?v=aNf1Oos0ZB8&t=1s), Codenares 2018 and 2019, [Ritsi](https://www.youtube.com/watch?v=SuykoyC0T74&t=1s) and several internal talks at my company, like [this one](https://www.youtube.com/watch?v=RFQy-ud8Ec4&t=4477s)."],["talks_title","Charlas"],["talks_talkTitle","Title"],["talks_talkAbstract","Descripción"],["talks_talkTopics","Temas"],["talks_talkDifficulty","Dificultad"],["talks_talkLength","Duración"],["talks_talkDifficultyAdvanced","Avanzado"],["talks_talkDifficultyIntermediate","Intermedio"],["talks_talkDifficultyEasy","Fácil"]]),u=new r.a([["_theme","Theme"],["_language","Language"],["_en","English"],["_es","Spanish"],["_dark","Dark"],["_light","Light"],["home_title","Home"],["home_recentArticles","Recent articles"],["article_title","Articles"],["about_title","About me"],["about_description","I'm a young programmer very interested in good practices, architecture, testing and SOLID principles. I work at [Autentia](https://www.autentia.com/) as a frontend developer (Vue, React, TypeScript, JavaScript, HTML, CSS, etc) although I have worked a bit in Java and Android. I'm continuously on the lookout for things to read, learn and [share](https://www.adictosaltrabajo.com/author/calberca/). I've talked at [JSDay Madrid](https://www.youtube.com/watch?v=aNf1Oos0ZB8&t=1s), Codenares 2018 and 2019, [Ritsi](https://www.youtube.com/watch?v=SuykoyC0T74&t=1s) and several internal talks at my company, like [this one](https://www.youtube.com/watch?v=RFQy-ud8Ec4&t=4477s)."],["talks_title","Talks"],["talks_talkTitle","Title"],["talks_talkAbstract","Abstract"],["talks_talkTopics","Topics"],["talks_talkDifficulty","Difficulty"],["talks_talkLength","Length"],["talks_talkDifficultyAdvanced","Advanced"],["talks_talkDifficultyIntermediate","Intermediate"],["talks_talkDifficultyEasy","Easy"]]);(function(e){e[e["EN"]=0]="EN",e[e["ES"]=1]="ES",e[e["DEFAULT"]=0]="DEFAULT"})(o||(o={}));var l=function(){function e(){Object(s["a"])(this,e),this.translations=new r.a([[o.ES,c],[o.EN,u]])}return Object(i["a"])(e,[{key:"getDefaultLocaleTranslation",value:function(){return this.translations.get(o.DEFAULT)}}],[{key:"create",value:function(){return new e}}]),e}(),p=n("308d"),m=n("6bb5"),d=n("4e2b"),h=n("f28b"),v=function(e){function t(e){return Object(s["a"])(this,t),Object(p["a"])(this,Object(m["a"])(t).call(this,e))}return Object(d["a"])(t,e),t}(Object(h["a"])(Error));n("6516");n.d(t,"c",function(){return l}),n.d(t,"a",function(){return o}),n.d(t,"b",function(){return v})},"4e1d":function(e,t){e.exports={body:"english\n\x3c!--more--\x3e\n\n\x3c!-- START doctoc generated TOC please keep comment here to allow auto update --\x3e\n\x3c!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --\x3e\n\n## Índice\n\n-   [1. Usa TypeScript](#1-usa-typescript)\n-   [2. Usa Inject/Provide](#2-usa-injectprovide)\n-   [3. Usa componentes y contenedores](#3-usa-componentes-y-contenedores)\n-   [4. Haz testing](#4-haz-testing)\n-   [5. Mueve lógica de negocio fuera de los componentes](#5-mueve-l%C3%B3gica-de-negocio-fuera-de-los-componentes)\n-   [Conclusión](#conclusi%C3%B3n)\n\n\x3c!-- END doctoc generated TOC please keep comment here to allow auto update --\x3e\n\n[Vue](https://vuejs.org/) es un framework progresivo, versatil y que tiende a la optimización. Opta por la simplicidad en algunos aspectos y adopta cosas de [React](https://reactjs.org/) y [Angular](https://angular.io/). En este post veremos consejos para que tu código con Vue sea impoluto y fácil de testear.\n\nEl ejemplo en vivo lo tienes aquí: [https://codesandbox.io/s/rw7jm9ovzo](https://codesandbox.io/s/rw7jm9ovzo) y el código en Github: [https://github.com/cesalberca/gravatar-viewer](https://github.com/cesalberca/gravatar-viewer).\n\n## 1. Usa TypeScript\n\n[TypeScript](https://www.typescriptlang.org/) te va a ayudar mucho a detectar errores antes de que ejecutes el programa, vas a ser más productivo ya que tu IDE te va a ofrecer más ayudas y tendrás documentación acerca de las estructuras y modelos que usas en tu aplicación.\n\n[Vue da soporte a TypeScript](https://vuejs.org/v2/guide/typescript.html), e incluso [han anunciado con la versión 3](https://medium.com/the-vue-point/plans-for-the-next-iteration-of-vue-js-777ffea6fabf) un rewrite de Vue en TypeScript. Hasta entonces el soporte que dan en ficheros `.vue` deja un poco que desear, ya que dependes de extensiones como [Vetur](https://github.com/vuejs/vetur) o que tu IDE de un buen soporte.\n\nPor las razones antes mencionadas, y dado que han anunciado que en el nuevo API será orientada a clases y no a objetos yo recomiendo usar [vue-class-component](https://github.com/vuejs/vue-class-component) y [vue-property-decorator](https://github.com/kaorun343/vue-property-decorator). Con estas bibliotecas logramos que nuestro código sea más legible y más seguro en cuanto a tipos. Si usas [Vuex](https://vuex.vuejs.org/guide/) te recomiendo que eches un ojo a [vuex-class](https://github.com/ktsn/vuex-class).\n\n_Nota: Estas bibliotecas están arropadas por Vue. Su creador es un [miembro core del equipo de Vue](https://github.com/ktsn) que lleva toda la parte de TypeScript dentro de Vue._\n\n## 2. Usa Inject/Provide\n\n[Inject / provide](https://vuejs.org/v2/api/#provide-inject) es una API de Vue para hacer las veces de un contenedor simple de IoC, donde podremos proveer de dependencias dentro de un árbol de componentes a cualquier nivel, lo que evita en cierta medida el denominado [prop drilling](https://blog.kentcdodds.com/prop-drilling-bb62e02cb691).\n\nUn mecanismo análogo en React sería el API de [contexto](https://reactjs.org/docs/context.html).\n\nAhora veamos cómo lo usaríamos en una mini aplicación que hace peticiones al API de [Libravatar](https://www.libravatar.org/) para mostrar el avatar de un usuario buscando por su email.\n\nComenzamos imaginando que nuestro componente llama a un [repositorio](https://deviq.com/repository-pattern/):\n\n```html\n<template>\n    <section class=\"viewer\">\n        <header>\n            <h1>Gravatar Viewer</h1>\n            <label for=\"email\">Email</label>\n            <input name=\"email\" type=\"email\" v-model=\"email\" class=\"email\" />\n        </header>\n\n        <main v-if=\"showUser\">\n            <h3>User</h3>\n            <img :src=\"user.photo\" alt=\"User image\" />\n        </main>\n    </section>\n</template>\n<script lang=\"ts\">\nimport { Component, Vue, Watch } from 'vue-property-decorator'\nimport { GravatarRepository } from '../domains/gravatar/repositories/GravatarRepository'\nimport { GravatarRepositoryFactory } from '../domains/gravatar/repositories/GravatarRepositoryFactory'\nimport { User } from '../domains/users/User'\nimport md5 from 'md5'\nimport { debounce } from '../utils/debounce'\n\n@Component\nexport default class UserComponent extends Vue {\n    email: string = ''\n    user: User = User.empty()\n    gravatarRepository: GravatarRepository = GravatarRepositoryFactory.photo()\n    debouncedQueryEmail!: () => void\n\n    created() {\n        this.debouncedQueryEmail = debounce(this.queryEmail, 1000)\n    }\n\n    get showUser() {\n        return this.user.exists()\n    }\n\n    @Watch('email')\n    onEmailChange() {\n        this.debouncedQueryEmail()\n    }\n\n    async queryEmail() {\n        const hash = md5(this.email)\n        const user = await this.gravatarRepository.getUserByEmailHash(hash)\n        this.user = user\n    }\n}\n<\/script>\n<style scoped>\n.viewer {\n    width: 100%;\n    height: 100vh;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n}\n\n.email {\n    margin-left: 8px;\n}\n</style>\n```\n\nAquí tendremos un problema muy grande si queremos mañana consumir un repositorio distinto. Tendremos que cambiar _todos_ los componentes donde haya una concreción como la hay cuando se llama a la factoría `GravatarRepositoryFactory.photo()`.\n\nAdemás los tests de este componente van a ser insufribles, porque tendremos que de alguna forma mockear el import, ya que no queremos que haga peticiones de verdad en el test unitario ya que este pasaría de ser unitario a de integración.\n\n_Nota: La función `debounce` hace que un método no se ejecute hasta que pase un tiempo mínimo de 1000ms, lo que evita que hagamos un montón de peticiones al API._\n\nCon inject podemos mejorar esta situación:\n\n```html\n<template>\n    <section class=\"viewer\">\n        <header>\n            <h1>Gravatar Viewer</h1>\n            <label for=\"email\">Email</label>\n            <input name=\"email\" type=\"email\" v-model=\"email\" class=\"email\" />\n        </header>\n\n        <main v-if=\"showUser\">\n            <h3>User</h3>\n            <img :src=\"user.photo\" alt=\"User image\" />\n        </main>\n    </section>\n</template>\n<script lang=\"ts\">\nimport { Component, Vue, Watch, Inject } from 'vue-property-decorator'\nimport { GravatarRepository } from '../domains/gravatar/repositories/GravatarRepository'\nimport { User } from '../domains/users/User'\nimport md5 from 'md5'\nimport { debounce } from '../utils/debounce'\n\n@Component\nexport default class UserComponent extends Vue {\n    email: string = ''\n    user: User = User.empty()\n\n    @Inject()\n    gravatarRepository!: GravatarRepository\n\n    debouncedQueryEmail!: () => void\n\n    created() {\n        this.debouncedQueryEmail = debounce(this.queryEmail, 1000)\n    }\n\n    get showUser() {\n        return this.user.exists()\n    }\n\n    @Watch('email')\n    onEmailChange() {\n        this.debouncedQueryEmail()\n    }\n\n    async queryEmail() {\n        const hash = md5(this.email)\n        const user = await this.gravatarRepository.getUserByEmailHash(hash)\n        this.user = user\n    }\n}\n<\/script>\n<style scoped>\n.viewer {\n    width: 100%;\n    height: 100vh;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n}\n\n.email {\n    margin-left: 8px;\n}\n</style>\n```\n\nEl cambio es muy sutil, pero muy efectivo. Ahora nos falta proveer de la implementación de `GravatarRepository` (que adelanto que es una interfaz). Para ello nos podemos crear un componente `ProviderFactory` que sea el que se encarga de gestionar la creación de instancias y el que las inyecta:\n\n```html\n<template>\n    <div><slot /></div>\n</template>\n<script lang=\"ts\">\nimport { Component, Vue, Provide } from 'vue-property-decorator'\nimport { GravatarRepositoryFactory } from './../domains/gravatar/repositories/GravatarRepositoryFactory'\nimport { GravatarRepository } from './../domains/gravatar/repositories/GravatarRepository'\nimport { debounce } from './../utils/debounce'\nimport { hasher } from './../utils/hasher'\n\n@Component\nexport default class ProviderFactory extends Vue {\n    @Provide()\n    gravatarRepository: GravatarRepository = GravatarRepositoryFactory.photo()\n}\n<\/script>\n```\n\nY ahora en el fichero `App.vue` haremos uso de él:\n\n```html\n<template>\n    <ProviderFactory> <AvatarViewerContainer /> </ProviderFactory>\n</template>\n\n<script lang=\"ts\">\nimport { Vue, Component } from 'vue-property-decorator'\nimport AvatarViewerContainer from './components/AvatarViewerContainer.vue'\nimport ProviderFactory from './components/ProviderFactory.vue'\n\n@Component({\n    components: {\n        AvatarViewerContainer,\n        ProviderFactory\n    }\n})\nexport default class App extends Vue {}\n<\/script>\n```\n\nSi mañana tenemos un nuevo repositorio basado en local storage, solamente tendríamos que cambiarlo en el `ProviderFactory`. Incluso podríamos jugar a cambiar la implementación en caliente basándonos en cierta lógica.\n\nEl test además sería mucho más fácil, ya que podríamos decir que para el test se haga un provide de un mock.\n\n¿Identificas además otra dependencia en el componente? Sí, el `md5` y el `debounce` son una concreción, si queremos seguir la D de [SOLID](https://en.wikipedia.org/wiki/SOLID) no deberíamos depender de concreciones si no de abstracciones.\n\n## 3. Usa componentes y contenedores\n\nLos componentes y contenedores no son más que el patrón de diseño [Mediator](https://en.wikipedia.org/wiki/Mediator_pattern). Donde los componentes serán los que se encargar de pintar, podrán tener lógica de pintado, pero muy poca. Reciben datos y los pintas, nada más. Los contenedores son aquellos que orquestan a los componentes y les pasan los datos. Suelen tener más lógica pero no suelen tener ni estilos visuales ni markup.\n\nLos componentes se comunican con los contenedores mediante eventos, y los contenedores se comunican con los componentes mediante props. Esto hace que los tests sean mucho más fáciles, los componentes estén más desacoplados y si falla algo en cuanto a la orquestación, sabremos que tenemos que mirar el contenedor.\n\nComo ejemplo vamos a refactorizar nuestro componente `UserComponenteInject`. Creamos primero el componente `AvatarComponent`\n\n```html\n<template>\n    <div v-if=\"showUser\">\n        <h3>User</h3>\n        <img :src=\"user.photo\" alt=\"User image\" />\n    </div>\n</template>\n<script lang=\"ts\">\nimport { Prop, Component, Vue } from 'vue-property-decorator'\nimport { User } from '../domains/users/User'\n\n@Component\nexport default class AvatarComponent extends Vue {\n    @Prop({ type: Object, default: () => User.empty() })\n    user!: User\n\n    get showUser() {\n        return this.user.exists()\n    }\n}\n<\/script>\n```\n\nAhora podemos crear el componente que se encarga del input del email. Creamos el componente `UserForm`:\n\n```html\n<template>\n    <header>\n        <h1>Gravatar Viewer</h1>\n        <label for=\"email\">Email</label>\n        <input name=\"email\" type=\"email\" @input=\"onEmailChange\" class=\"email\" />\n    </header>\n</template>\n<script lang=\"ts\">\nimport { Component, Vue, Emit } from 'vue-property-decorator'\n\n@Component\nexport default class UserFormComponent extends Vue {\n    @Emit()\n    onEmailChange(event: Event) {\n        return (event.target as HTMLInputElement).value\n    }\n}\n<\/script>\n<style scoped>\n.email {\n    margin-left: 8px;\n}\n</style>\n```\n\nY por último creamos `AvatarViewerContainer`:\n\n```html\n<template>\n    <section class=\"viewer\">\n        <UserFormComponent @on-email-change=\"updateEmail\" />\n        <AvatarComponent :user=\"user\" />\n    </section>\n</template>\n<script lang=\"ts\">\nimport { Component, Vue, Watch, Inject } from 'vue-property-decorator'\nimport { GravatarRepository } from '../domains/gravatar/repositories/GravatarRepository'\nimport UserFormComponent from './UserFormComponent.vue'\nimport AvatarComponent from './AvatarComponent.vue'\nimport { User } from '../domains/users/User'\nimport { debounce } from '../utils/debounce'\nimport { hasher } from '../utils/hasher'\n\n@Component({\n    components: {\n        AvatarComponent,\n        UserFormComponent\n    }\n})\nexport default class AvatarViewerContainer extends Vue {\n    email: string = ''\n    user: User = User.empty()\n\n    @Inject()\n    gravatarRepository!: GravatarRepository\n\n    @Inject()\n    debounce!: typeof debounce\n\n    @Inject()\n    hasher!: typeof hasher\n\n    debouncedQueryEmail!: () => void\n\n    created() {\n        this.debouncedQueryEmail = this.debounce(this.queryEmail, 1000)\n    }\n\n    @Watch('email')\n    onEmailChange() {\n        this.debouncedQueryEmail()\n    }\n\n    updateEmail(email: string) {\n        this.email = email\n    }\n\n    async queryEmail() {\n        const hash = this.hasher(this.email)\n        const user = await this.gravatarRepository.getUserByEmailHash(hash)\n        this.user = user\n    }\n}\n<\/script>\n<style scoped>\n.viewer {\n    width: 100%;\n    height: 100vh;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n}\n</style>\n```\n\nTambién modificamos el ProviderFactory para inyectar el `debounce` y el `hasher`:\n\n```html\n<template>\n    <div><slot /></div>\n</template>\n<script lang=\"ts\">\nimport { Component, Vue, Provide } from 'vue-property-decorator'\nimport { GravatarRepositoryFactory } from './../domains/gravatar/repositories/GravatarRepositoryFactory'\nimport { GravatarRepository } from './../domains/gravatar/repositories/GravatarRepository'\nimport { debounce } from './../utils/debounce'\nimport { hasher } from './../utils/hasher'\n\n@Component\nexport default class ProviderFactory extends Vue {\n    @Provide()\n    gravatarRepository: GravatarRepository = GravatarRepositoryFactory.photo()\n\n    @Provide()\n    debounce = debounce\n\n    @Provide()\n    hasher = hasher\n}\n<\/script>\n```\n\n## 4. Haz testing\n\nComo puedes ver en proyecto de ejemplo, todos los componentes y piezas están testadas. Al seguir SOLID y buenas prácticas el añadir test unitarios de todo lo necesario es trivial.\n\nPor ejemplo veamos el `AvatarViewerContainer.spec.ts`:\n\n```typescript\nimport Vue from 'vue'\nimport AvatarViewerContainer from './../AvatarViewerContainer.vue'\nimport { Wrapper, shallowMount } from '@vue/test-utils'\nimport { User } from '../../domains/users/User'\nimport { flushPromises } from '../../utils/flushPromises'\nimport { hasher } from '../../utils/hasher'\nimport { debounce } from '../../utils/debounce'\nimport { GravatarRepository } from '../../domains/gravatar/repositories/GravatarRepository'\n\ndescribe('AvatarViewerContainer', () => {\n    let wrapper: Wrapper<Vue>\n    let gravatarRepositoryMock: GravatarRepository\n    let debounceMock: typeof debounce\n    let hasherMock: typeof hasher\n\n    beforeEach(() => {\n        hasherMock = jest.fn()\n        debounceMock = jest.fn((func: Function) => () => func())\n        gravatarRepositoryMock = {\n            getUserByEmailHash: jest.fn().mockReturnValue(Promise.resolve(new User('foo')))\n        }\n\n        wrapper = shallowMount(AvatarViewerContainer, {\n            provide: {\n                gravatarRepository: gravatarRepositoryMock,\n                debounce: debounceMock,\n                hasher: hasherMock\n            }\n        })\n    })\n\n    it('should call gravatarRepository when email changes', async () => {\n        const userFormComponent = wrapper.find({ name: 'UserFormComponent' })\n\n        userFormComponent.vm.$emit('on-email-change', 'foo@foo.com')\n        await flushPromises()\n\n        expect(gravatarRepositoryMock.getUserByEmailHash).toHaveBeenCalled()\n    })\n\n    it('should debounce call when email changes', async () => {\n        const userFormComponent = wrapper.find({ name: 'UserFormComponent' })\n\n        userFormComponent.vm.$emit('on-email-change', 'foo@foo.com')\n        await flushPromises()\n\n        expect(debounceMock).toHaveBeenCalled()\n    })\n\n    it('should set user to AvatarComponent', async () => {\n        const userFormComponent = wrapper.find({ name: 'UserFormComponent' })\n        const avatarComponent = wrapper.find({ name: 'AvatarComponent' })\n\n        userFormComponent.vm.$emit('on-email-change', 'foo@foo.com')\n        await flushPromises()\n\n        expect(avatarComponent.props('user').photo).toBe('foo')\n    })\n\n    it('should use the hasher', async () => {\n        expect.assertions(1)\n\n        const userFormComponent = wrapper.find({ name: 'UserFormComponent' })\n\n        userFormComponent.vm.$emit('on-email-change', 'foo@foo.com')\n        await flushPromises()\n\n        expect(hasherMock).toHaveBeenCalledWith('foo@foo.com')\n    })\n})\n```\n\nO el componente `AvatarComponent.spec.ts`:\n\n```typescript\nimport Vue from 'vue'\nimport AvatarComponent from '../AvatarComponent.vue'\nimport { Wrapper, shallowMount } from '@vue/test-utils'\nimport { User } from '../../domains/users/User'\n\ndescribe('AvatarComponent', () => {\n    let wrapper: Wrapper<Vue>\n\n    beforeEach(() => {\n        wrapper = shallowMount(AvatarComponent)\n    })\n\n    it(\"should hide if the user doesn't exist\", () => {\n        wrapper.setProps({ user: User.empty() })\n\n        expect(wrapper.html()).toBeUndefined()\n    })\n\n    it('should show if the user exists', () => {\n        wrapper.setProps({ user: new User('foo') })\n\n        expect(wrapper.html()).toBeDefined()\n    })\n\n    it(\"should set the image url with the user's photo\", () => {\n        wrapper.setProps({ user: new User('foo') })\n\n        const image = wrapper.find('img')\n        expect(image.attributes('src')).toEqual('foo')\n    })\n})\n```\n\nY el `UserFormComponent`:\n\n```typescript\nimport Vue from 'vue'\nimport UserFormComponent from './../UserFormComponent.vue'\nimport { shallowMount, Wrapper } from '@vue/test-utils'\n\ndescribe('UserFormComponent', () => {\n    let wrapper: Wrapper<Vue>\n\n    beforeEach(() => {\n        wrapper = shallowMount(UserFormComponent)\n    })\n\n    it('should emit event', () => {\n        const input = wrapper.find('input')\n        ;(input.element as HTMLInputElement).value = 'foo'\n        input.trigger('input')\n        expect(wrapper.emitted('on-email-change')[0][0]).toEqual('foo')\n    })\n})\n```\n\nNo hacer testing **nunca** está justificado.\n\n## 5. Mueve lógica de negocio fuera de los componentes\n\nComo hemos visto antes en el contenedor `AvatarViewerContainer` había un `GravatarRepository`. Básicamente este repositorio luego por debajo se conecta con un API y te devuelve la imagen del usuario. Podríamos hacer la llamada en el contenedor directamente, pero estaríamos acoplando nuestra obtención de datos con un framework (Vue) y romperíamos SOLID, ya que el motivo de cambio del contenedor es que la interacción cambie o que el API cambie.\n\nVeamos más detenidamente `GravatarRepository`:\n\n```typescript\nimport { User } from '../../users/User'\n\nexport interface GravatarRepository {\n    getUserByEmailHash(hash: string): Promise<User>\n}\n```\n\nPues resulta que es una interfaz. ¿Por qué? Porque esto nos permite definir varios repositorios para acceder a los datos. Podríamos tener una implementación de esta interfaz en `GravatarHttpRepository`, `GravatarLocalStorageRepository` o `GravatarBlobRepository` como es nuestro caso. Además podríamos cambiar la implementación tanto en \"compilación\" como en caliente.\n\nAquí está `GravatarBlobRepository`:\n\n```typescript\nimport { GravatarRepository } from './GravatarRepository'\nimport { User } from '../../users/User'\nimport { Fetcher } from '../../Fetcher'\n\nexport class GravatarBlobRepository implements GravatarRepository {\n    private url: string\n\n    constructor(private readonly fetcher: Fetcher) {\n        this.url = 'https://cors-anywhere.herokuapp.com/https://seccdn.libravatar.org/avatar'\n    }\n\n    async getUserByEmailHash(hash: string): Promise<User> {\n        const response = await this.fetcher(`${this.url}/${hash}`)\n        const result = await response.blob()\n        const object = URL.createObjectURL(result)\n        return new User(object)\n    }\n}\n```\n\nPor constructor le hemos pasado un `fetcher`, este es el encargado de recoger los datos de una API y tiene el siguiente tipo:\n\n```typescript\nexport type Fetcher = <Response = any>(\n    query: string,\n    options?: {\n        mode: string\n    }\n) => Promise<{ json: () => Promise<Response>; blob: () => Promise<Response> }>\n```\n\nA aquellos que les suene verá que es igualito que el API de [fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API), que es el que usaremos luego en verdad.\n\nY por último, ¿dónde creamos la instancia de `GravatarBlobRepository`? Pues con una factoría.\n\n`GravataRepositoryFactory`:\n\n```typescript\nimport { GravatarRepository } from './GravatarRepository'\nimport { GravatarBlobRepository } from './GravatarBlobRepository'\nimport { Fetcher } from '../../Fetcher'\n\nexport class GravatarRepositoryFactory {\n    static photo(): GravatarRepository {\n        const fetcher = window.fetch.bind(window) as Fetcher\n        return new GravatarBlobRepository(fetcher)\n    }\n}\n```\n\nAquí vemos que hemos pasado de una abstracción `Fetcher` a una concreción: `window.fetch`, siendo en un futuro configurable e intercambiable por otra solución.\n\nPor último hemos modelado nuestro usuario con una clase. Aquí tenemos el modelo del `User`:\n\n```typescript\nexport class User {\n    constructor(private readonly photo: string) {}\n\n    static empty() {\n        return new User('')\n    }\n\n    exists(): boolean {\n        return this.photo.length !== 0\n    }\n}\n```\n\nEs importante evitar que nuestros modelos sean interfaces sin comportamiento o clases con setters o propiedades públicas, ya que nos pueden llevar a [modelos anémicos](https://www.martinfowler.com/bliki/AnemicDomainModel.html), es decir modelos que son una bolsa de propiedades, siendo imposible determinar cual es su estado válido, delegando en el consumidor la lógica de validez, lo que haría a su vez que duplicásemos esa lógica.\n\n## Conclusión\n\nEl front no es fácil. Venimos de un mundo dónde a lo más que podíamos aspirar es a maquetar, aplicar estilos y usar algo de JavaScript para lograr animaciones e interactividad con la página. Todo esto ha cambiado, ahora debemos gestionar un montón de estado, asincronía, optimización de peticiones y caché, diseño responsive, reactividad y un montón más de cosas.\n\n¿Por qué nos privamos de usar las herramientas y mecanismos que se llevan usando en la programación orientada a objetos desde hace más de 20 años que se han visto que funcionan?\n\nSígueme en [Twitter](https://twitter.com/) y en [Github](https://github.com/cesalberca).\n",html:"<p>english</p>\n\x3c!--more--\x3e\n\x3c!-- START doctoc generated TOC please keep comment here to allow auto update --\x3e\n\x3c!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE --\x3e\n<h2>Índice</h2>\n<ul>\n<li><a href=\"#1-usa-typescript\">1. Usa TypeScript</a></li>\n<li><a href=\"#2-usa-injectprovide\">2. Usa Inject/Provide</a></li>\n<li><a href=\"#3-usa-componentes-y-contenedores\">3. Usa componentes y contenedores</a></li>\n<li><a href=\"#4-haz-testing\">4. Haz testing</a></li>\n<li><a href=\"#5-mueve-l%C3%B3gica-de-negocio-fuera-de-los-componentes\">5. Mueve lógica de negocio fuera de los componentes</a></li>\n<li><a href=\"#conclusi%C3%B3n\">Conclusión</a></li>\n</ul>\n\x3c!-- END doctoc generated TOC please keep comment here to allow auto update --\x3e\n<p><a href=\"https://vuejs.org/\">Vue</a> es un framework progresivo, versatil y que tiende a la optimización. Opta por la simplicidad en algunos aspectos y adopta cosas de <a href=\"https://reactjs.org/\">React</a> y <a href=\"https://angular.io/\">Angular</a>. En este post veremos consejos para que tu código con Vue sea impoluto y fácil de testear.</p>\n<p>El ejemplo en vivo lo tienes aquí: <a href=\"https://codesandbox.io/s/rw7jm9ovzo\">https://codesandbox.io/s/rw7jm9ovzo</a> y el código en Github: <a href=\"https://github.com/cesalberca/gravatar-viewer\">https://github.com/cesalberca/gravatar-viewer</a>.</p>\n<h2>1. Usa TypeScript</h2>\n<p><a href=\"https://www.typescriptlang.org/\">TypeScript</a> te va a ayudar mucho a detectar errores antes de que ejecutes el programa, vas a ser más productivo ya que tu IDE te va a ofrecer más ayudas y tendrás documentación acerca de las estructuras y modelos que usas en tu aplicación.</p>\n<p><a href=\"https://vuejs.org/v2/guide/typescript.html\">Vue da soporte a TypeScript</a>, e incluso <a href=\"https://medium.com/the-vue-point/plans-for-the-next-iteration-of-vue-js-777ffea6fabf\">han anunciado con la versión 3</a> un rewrite de Vue en TypeScript. Hasta entonces el soporte que dan en ficheros <code>.vue</code> deja un poco que desear, ya que dependes de extensiones como <a href=\"https://github.com/vuejs/vetur\">Vetur</a> o que tu IDE de un buen soporte.</p>\n<p>Por las razones antes mencionadas, y dado que han anunciado que en el nuevo API será orientada a clases y no a objetos yo recomiendo usar <a href=\"https://github.com/vuejs/vue-class-component\">vue-class-component</a> y <a href=\"https://github.com/kaorun343/vue-property-decorator\">vue-property-decorator</a>. Con estas bibliotecas logramos que nuestro código sea más legible y más seguro en cuanto a tipos. Si usas <a href=\"https://vuex.vuejs.org/guide/\">Vuex</a> te recomiendo que eches un ojo a <a href=\"https://github.com/ktsn/vuex-class\">vuex-class</a>.</p>\n<p><em>Nota: Estas bibliotecas están arropadas por Vue. Su creador es un <a href=\"https://github.com/ktsn\">miembro core del equipo de Vue</a> que lleva toda la parte de TypeScript dentro de Vue.</em></p>\n<h2>2. Usa Inject/Provide</h2>\n<p><a href=\"https://vuejs.org/v2/api/#provide-inject\">Inject / provide</a> es una API de Vue para hacer las veces de un contenedor simple de IoC, donde podremos proveer de dependencias dentro de un árbol de componentes a cualquier nivel, lo que evita en cierta medida el denominado <a href=\"https://blog.kentcdodds.com/prop-drilling-bb62e02cb691\">prop drilling</a>.</p>\n<p>Un mecanismo análogo en React sería el API de <a href=\"https://reactjs.org/docs/context.html\">contexto</a>.</p>\n<p>Ahora veamos cómo lo usaríamos en una mini aplicación que hace peticiones al API de <a href=\"https://www.libravatar.org/\">Libravatar</a> para mostrar el avatar de un usuario buscando por su email.</p>\n<p>Comenzamos imaginando que nuestro componente llama a un <a href=\"https://deviq.com/repository-pattern/\">repositorio</a>:</p>\n<pre><code class=\"language-html\">&lt;template&gt;\n    &lt;section class=&quot;viewer&quot;&gt;\n        &lt;header&gt;\n            &lt;h1&gt;Gravatar Viewer&lt;/h1&gt;\n            &lt;label for=&quot;email&quot;&gt;Email&lt;/label&gt;\n            &lt;input name=&quot;email&quot; type=&quot;email&quot; v-model=&quot;email&quot; class=&quot;email&quot; /&gt;\n        &lt;/header&gt;\n\n        &lt;main v-if=&quot;showUser&quot;&gt;\n            &lt;h3&gt;User&lt;/h3&gt;\n            &lt;img :src=&quot;user.photo&quot; alt=&quot;User image&quot; /&gt;\n        &lt;/main&gt;\n    &lt;/section&gt;\n&lt;/template&gt;\n&lt;script lang=&quot;ts&quot;&gt;\nimport { Component, Vue, Watch } from 'vue-property-decorator'\nimport { GravatarRepository } from '../domains/gravatar/repositories/GravatarRepository'\nimport { GravatarRepositoryFactory } from '../domains/gravatar/repositories/GravatarRepositoryFactory'\nimport { User } from '../domains/users/User'\nimport md5 from 'md5'\nimport { debounce } from '../utils/debounce'\n\n@Component\nexport default class UserComponent extends Vue {\n    email: string = ''\n    user: User = User.empty()\n    gravatarRepository: GravatarRepository = GravatarRepositoryFactory.photo()\n    debouncedQueryEmail!: () =&gt; void\n\n    created() {\n        this.debouncedQueryEmail = debounce(this.queryEmail, 1000)\n    }\n\n    get showUser() {\n        return this.user.exists()\n    }\n\n    @Watch('email')\n    onEmailChange() {\n        this.debouncedQueryEmail()\n    }\n\n    async queryEmail() {\n        const hash = md5(this.email)\n        const user = await this.gravatarRepository.getUserByEmailHash(hash)\n        this.user = user\n    }\n}\n&lt;/script&gt;\n&lt;style scoped&gt;\n.viewer {\n    width: 100%;\n    height: 100vh;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n}\n\n.email {\n    margin-left: 8px;\n}\n&lt;/style&gt;\n</code></pre>\n<p>Aquí tendremos un problema muy grande si queremos mañana consumir un repositorio distinto. Tendremos que cambiar <em>todos</em> los componentes donde haya una concreción como la hay cuando se llama a la factoría <code>GravatarRepositoryFactory.photo()</code>.</p>\n<p>Además los tests de este componente van a ser insufribles, porque tendremos que de alguna forma mockear el import, ya que no queremos que haga peticiones de verdad en el test unitario ya que este pasaría de ser unitario a de integración.</p>\n<p><em>Nota: La función <code>debounce</code> hace que un método no se ejecute hasta que pase un tiempo mínimo de 1000ms, lo que evita que hagamos un montón de peticiones al API.</em></p>\n<p>Con inject podemos mejorar esta situación:</p>\n<pre><code class=\"language-html\">&lt;template&gt;\n    &lt;section class=&quot;viewer&quot;&gt;\n        &lt;header&gt;\n            &lt;h1&gt;Gravatar Viewer&lt;/h1&gt;\n            &lt;label for=&quot;email&quot;&gt;Email&lt;/label&gt;\n            &lt;input name=&quot;email&quot; type=&quot;email&quot; v-model=&quot;email&quot; class=&quot;email&quot; /&gt;\n        &lt;/header&gt;\n\n        &lt;main v-if=&quot;showUser&quot;&gt;\n            &lt;h3&gt;User&lt;/h3&gt;\n            &lt;img :src=&quot;user.photo&quot; alt=&quot;User image&quot; /&gt;\n        &lt;/main&gt;\n    &lt;/section&gt;\n&lt;/template&gt;\n&lt;script lang=&quot;ts&quot;&gt;\nimport { Component, Vue, Watch, Inject } from 'vue-property-decorator'\nimport { GravatarRepository } from '../domains/gravatar/repositories/GravatarRepository'\nimport { User } from '../domains/users/User'\nimport md5 from 'md5'\nimport { debounce } from '../utils/debounce'\n\n@Component\nexport default class UserComponent extends Vue {\n    email: string = ''\n    user: User = User.empty()\n\n    @Inject()\n    gravatarRepository!: GravatarRepository\n\n    debouncedQueryEmail!: () =&gt; void\n\n    created() {\n        this.debouncedQueryEmail = debounce(this.queryEmail, 1000)\n    }\n\n    get showUser() {\n        return this.user.exists()\n    }\n\n    @Watch('email')\n    onEmailChange() {\n        this.debouncedQueryEmail()\n    }\n\n    async queryEmail() {\n        const hash = md5(this.email)\n        const user = await this.gravatarRepository.getUserByEmailHash(hash)\n        this.user = user\n    }\n}\n&lt;/script&gt;\n&lt;style scoped&gt;\n.viewer {\n    width: 100%;\n    height: 100vh;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n}\n\n.email {\n    margin-left: 8px;\n}\n&lt;/style&gt;\n</code></pre>\n<p>El cambio es muy sutil, pero muy efectivo. Ahora nos falta proveer de la implementación de <code>GravatarRepository</code> (que adelanto que es una interfaz). Para ello nos podemos crear un componente <code>ProviderFactory</code> que sea el que se encarga de gestionar la creación de instancias y el que las inyecta:</p>\n<pre><code class=\"language-html\">&lt;template&gt;\n    &lt;div&gt;&lt;slot /&gt;&lt;/div&gt;\n&lt;/template&gt;\n&lt;script lang=&quot;ts&quot;&gt;\nimport { Component, Vue, Provide } from 'vue-property-decorator'\nimport { GravatarRepositoryFactory } from './../domains/gravatar/repositories/GravatarRepositoryFactory'\nimport { GravatarRepository } from './../domains/gravatar/repositories/GravatarRepository'\nimport { debounce } from './../utils/debounce'\nimport { hasher } from './../utils/hasher'\n\n@Component\nexport default class ProviderFactory extends Vue {\n    @Provide()\n    gravatarRepository: GravatarRepository = GravatarRepositoryFactory.photo()\n}\n&lt;/script&gt;\n</code></pre>\n<p>Y ahora en el fichero <code>App.vue</code> haremos uso de él:</p>\n<pre><code class=\"language-html\">&lt;template&gt;\n    &lt;ProviderFactory&gt; &lt;AvatarViewerContainer /&gt; &lt;/ProviderFactory&gt;\n&lt;/template&gt;\n\n&lt;script lang=&quot;ts&quot;&gt;\nimport { Vue, Component } from 'vue-property-decorator'\nimport AvatarViewerContainer from './components/AvatarViewerContainer.vue'\nimport ProviderFactory from './components/ProviderFactory.vue'\n\n@Component({\n    components: {\n        AvatarViewerContainer,\n        ProviderFactory\n    }\n})\nexport default class App extends Vue {}\n&lt;/script&gt;\n</code></pre>\n<p>Si mañana tenemos un nuevo repositorio basado en local storage, solamente tendríamos que cambiarlo en el <code>ProviderFactory</code>. Incluso podríamos jugar a cambiar la implementación en caliente basándonos en cierta lógica.</p>\n<p>El test además sería mucho más fácil, ya que podríamos decir que para el test se haga un provide de un mock.</p>\n<p>¿Identificas además otra dependencia en el componente? Sí, el <code>md5</code> y el <code>debounce</code> son una concreción, si queremos seguir la D de <a href=\"https://en.wikipedia.org/wiki/SOLID\">SOLID</a> no deberíamos depender de concreciones si no de abstracciones.</p>\n<h2>3. Usa componentes y contenedores</h2>\n<p>Los componentes y contenedores no son más que el patrón de diseño <a href=\"https://en.wikipedia.org/wiki/Mediator_pattern\">Mediator</a>. Donde los componentes serán los que se encargar de pintar, podrán tener lógica de pintado, pero muy poca. Reciben datos y los pintas, nada más. Los contenedores son aquellos que orquestan a los componentes y les pasan los datos. Suelen tener más lógica pero no suelen tener ni estilos visuales ni markup.</p>\n<p>Los componentes se comunican con los contenedores mediante eventos, y los contenedores se comunican con los componentes mediante props. Esto hace que los tests sean mucho más fáciles, los componentes estén más desacoplados y si falla algo en cuanto a la orquestación, sabremos que tenemos que mirar el contenedor.</p>\n<p>Como ejemplo vamos a refactorizar nuestro componente <code>UserComponenteInject</code>. Creamos primero el componente <code>AvatarComponent</code></p>\n<pre><code class=\"language-html\">&lt;template&gt;\n    &lt;div v-if=&quot;showUser&quot;&gt;\n        &lt;h3&gt;User&lt;/h3&gt;\n        &lt;img :src=&quot;user.photo&quot; alt=&quot;User image&quot; /&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n&lt;script lang=&quot;ts&quot;&gt;\nimport { Prop, Component, Vue } from 'vue-property-decorator'\nimport { User } from '../domains/users/User'\n\n@Component\nexport default class AvatarComponent extends Vue {\n    @Prop({ type: Object, default: () =&gt; User.empty() })\n    user!: User\n\n    get showUser() {\n        return this.user.exists()\n    }\n}\n&lt;/script&gt;\n</code></pre>\n<p>Ahora podemos crear el componente que se encarga del input del email. Creamos el componente <code>UserForm</code>:</p>\n<pre><code class=\"language-html\">&lt;template&gt;\n    &lt;header&gt;\n        &lt;h1&gt;Gravatar Viewer&lt;/h1&gt;\n        &lt;label for=&quot;email&quot;&gt;Email&lt;/label&gt;\n        &lt;input name=&quot;email&quot; type=&quot;email&quot; @input=&quot;onEmailChange&quot; class=&quot;email&quot; /&gt;\n    &lt;/header&gt;\n&lt;/template&gt;\n&lt;script lang=&quot;ts&quot;&gt;\nimport { Component, Vue, Emit } from 'vue-property-decorator'\n\n@Component\nexport default class UserFormComponent extends Vue {\n    @Emit()\n    onEmailChange(event: Event) {\n        return (event.target as HTMLInputElement).value\n    }\n}\n&lt;/script&gt;\n&lt;style scoped&gt;\n.email {\n    margin-left: 8px;\n}\n&lt;/style&gt;\n</code></pre>\n<p>Y por último creamos <code>AvatarViewerContainer</code>:</p>\n<pre><code class=\"language-html\">&lt;template&gt;\n    &lt;section class=&quot;viewer&quot;&gt;\n        &lt;UserFormComponent @on-email-change=&quot;updateEmail&quot; /&gt;\n        &lt;AvatarComponent :user=&quot;user&quot; /&gt;\n    &lt;/section&gt;\n&lt;/template&gt;\n&lt;script lang=&quot;ts&quot;&gt;\nimport { Component, Vue, Watch, Inject } from 'vue-property-decorator'\nimport { GravatarRepository } from '../domains/gravatar/repositories/GravatarRepository'\nimport UserFormComponent from './UserFormComponent.vue'\nimport AvatarComponent from './AvatarComponent.vue'\nimport { User } from '../domains/users/User'\nimport { debounce } from '../utils/debounce'\nimport { hasher } from '../utils/hasher'\n\n@Component({\n    components: {\n        AvatarComponent,\n        UserFormComponent\n    }\n})\nexport default class AvatarViewerContainer extends Vue {\n    email: string = ''\n    user: User = User.empty()\n\n    @Inject()\n    gravatarRepository!: GravatarRepository\n\n    @Inject()\n    debounce!: typeof debounce\n\n    @Inject()\n    hasher!: typeof hasher\n\n    debouncedQueryEmail!: () =&gt; void\n\n    created() {\n        this.debouncedQueryEmail = this.debounce(this.queryEmail, 1000)\n    }\n\n    @Watch('email')\n    onEmailChange() {\n        this.debouncedQueryEmail()\n    }\n\n    updateEmail(email: string) {\n        this.email = email\n    }\n\n    async queryEmail() {\n        const hash = this.hasher(this.email)\n        const user = await this.gravatarRepository.getUserByEmailHash(hash)\n        this.user = user\n    }\n}\n&lt;/script&gt;\n&lt;style scoped&gt;\n.viewer {\n    width: 100%;\n    height: 100vh;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n}\n&lt;/style&gt;\n</code></pre>\n<p>También modificamos el ProviderFactory para inyectar el <code>debounce</code> y el <code>hasher</code>:</p>\n<pre><code class=\"language-html\">&lt;template&gt;\n    &lt;div&gt;&lt;slot /&gt;&lt;/div&gt;\n&lt;/template&gt;\n&lt;script lang=&quot;ts&quot;&gt;\nimport { Component, Vue, Provide } from 'vue-property-decorator'\nimport { GravatarRepositoryFactory } from './../domains/gravatar/repositories/GravatarRepositoryFactory'\nimport { GravatarRepository } from './../domains/gravatar/repositories/GravatarRepository'\nimport { debounce } from './../utils/debounce'\nimport { hasher } from './../utils/hasher'\n\n@Component\nexport default class ProviderFactory extends Vue {\n    @Provide()\n    gravatarRepository: GravatarRepository = GravatarRepositoryFactory.photo()\n\n    @Provide()\n    debounce = debounce\n\n    @Provide()\n    hasher = hasher\n}\n&lt;/script&gt;\n</code></pre>\n<h2>4. Haz testing</h2>\n<p>Como puedes ver en proyecto de ejemplo, todos los componentes y piezas están testadas. Al seguir SOLID y buenas prácticas el añadir test unitarios de todo lo necesario es trivial.</p>\n<p>Por ejemplo veamos el <code>AvatarViewerContainer.spec.ts</code>:</p>\n<pre><code class=\"language-typescript\">import Vue from 'vue'\nimport AvatarViewerContainer from './../AvatarViewerContainer.vue'\nimport { Wrapper, shallowMount } from '@vue/test-utils'\nimport { User } from '../../domains/users/User'\nimport { flushPromises } from '../../utils/flushPromises'\nimport { hasher } from '../../utils/hasher'\nimport { debounce } from '../../utils/debounce'\nimport { GravatarRepository } from '../../domains/gravatar/repositories/GravatarRepository'\n\ndescribe('AvatarViewerContainer', () =&gt; {\n    let wrapper: Wrapper&lt;Vue&gt;\n    let gravatarRepositoryMock: GravatarRepository\n    let debounceMock: typeof debounce\n    let hasherMock: typeof hasher\n\n    beforeEach(() =&gt; {\n        hasherMock = jest.fn()\n        debounceMock = jest.fn((func: Function) =&gt; () =&gt; func())\n        gravatarRepositoryMock = {\n            getUserByEmailHash: jest.fn().mockReturnValue(Promise.resolve(new User('foo')))\n        }\n\n        wrapper = shallowMount(AvatarViewerContainer, {\n            provide: {\n                gravatarRepository: gravatarRepositoryMock,\n                debounce: debounceMock,\n                hasher: hasherMock\n            }\n        })\n    })\n\n    it('should call gravatarRepository when email changes', async () =&gt; {\n        const userFormComponent = wrapper.find({ name: 'UserFormComponent' })\n\n        userFormComponent.vm.$emit('on-email-change', 'foo@foo.com')\n        await flushPromises()\n\n        expect(gravatarRepositoryMock.getUserByEmailHash).toHaveBeenCalled()\n    })\n\n    it('should debounce call when email changes', async () =&gt; {\n        const userFormComponent = wrapper.find({ name: 'UserFormComponent' })\n\n        userFormComponent.vm.$emit('on-email-change', 'foo@foo.com')\n        await flushPromises()\n\n        expect(debounceMock).toHaveBeenCalled()\n    })\n\n    it('should set user to AvatarComponent', async () =&gt; {\n        const userFormComponent = wrapper.find({ name: 'UserFormComponent' })\n        const avatarComponent = wrapper.find({ name: 'AvatarComponent' })\n\n        userFormComponent.vm.$emit('on-email-change', 'foo@foo.com')\n        await flushPromises()\n\n        expect(avatarComponent.props('user').photo).toBe('foo')\n    })\n\n    it('should use the hasher', async () =&gt; {\n        expect.assertions(1)\n\n        const userFormComponent = wrapper.find({ name: 'UserFormComponent' })\n\n        userFormComponent.vm.$emit('on-email-change', 'foo@foo.com')\n        await flushPromises()\n\n        expect(hasherMock).toHaveBeenCalledWith('foo@foo.com')\n    })\n})\n</code></pre>\n<p>O el componente <code>AvatarComponent.spec.ts</code>:</p>\n<pre><code class=\"language-typescript\">import Vue from 'vue'\nimport AvatarComponent from '../AvatarComponent.vue'\nimport { Wrapper, shallowMount } from '@vue/test-utils'\nimport { User } from '../../domains/users/User'\n\ndescribe('AvatarComponent', () =&gt; {\n    let wrapper: Wrapper&lt;Vue&gt;\n\n    beforeEach(() =&gt; {\n        wrapper = shallowMount(AvatarComponent)\n    })\n\n    it(&quot;should hide if the user doesn't exist&quot;, () =&gt; {\n        wrapper.setProps({ user: User.empty() })\n\n        expect(wrapper.html()).toBeUndefined()\n    })\n\n    it('should show if the user exists', () =&gt; {\n        wrapper.setProps({ user: new User('foo') })\n\n        expect(wrapper.html()).toBeDefined()\n    })\n\n    it(&quot;should set the image url with the user's photo&quot;, () =&gt; {\n        wrapper.setProps({ user: new User('foo') })\n\n        const image = wrapper.find('img')\n        expect(image.attributes('src')).toEqual('foo')\n    })\n})\n</code></pre>\n<p>Y el <code>UserFormComponent</code>:</p>\n<pre><code class=\"language-typescript\">import Vue from 'vue'\nimport UserFormComponent from './../UserFormComponent.vue'\nimport { shallowMount, Wrapper } from '@vue/test-utils'\n\ndescribe('UserFormComponent', () =&gt; {\n    let wrapper: Wrapper&lt;Vue&gt;\n\n    beforeEach(() =&gt; {\n        wrapper = shallowMount(UserFormComponent)\n    })\n\n    it('should emit event', () =&gt; {\n        const input = wrapper.find('input')\n        ;(input.element as HTMLInputElement).value = 'foo'\n        input.trigger('input')\n        expect(wrapper.emitted('on-email-change')[0][0]).toEqual('foo')\n    })\n})\n</code></pre>\n<p>No hacer testing <strong>nunca</strong> está justificado.</p>\n<h2>5. Mueve lógica de negocio fuera de los componentes</h2>\n<p>Como hemos visto antes en el contenedor <code>AvatarViewerContainer</code> había un <code>GravatarRepository</code>. Básicamente este repositorio luego por debajo se conecta con un API y te devuelve la imagen del usuario. Podríamos hacer la llamada en el contenedor directamente, pero estaríamos acoplando nuestra obtención de datos con un framework (Vue) y romperíamos SOLID, ya que el motivo de cambio del contenedor es que la interacción cambie o que el API cambie.</p>\n<p>Veamos más detenidamente <code>GravatarRepository</code>:</p>\n<pre><code class=\"language-typescript\">import { User } from '../../users/User'\n\nexport interface GravatarRepository {\n    getUserByEmailHash(hash: string): Promise&lt;User&gt;\n}\n</code></pre>\n<p>Pues resulta que es una interfaz. ¿Por qué? Porque esto nos permite definir varios repositorios para acceder a los datos. Podríamos tener una implementación de esta interfaz en <code>GravatarHttpRepository</code>, <code>GravatarLocalStorageRepository</code> o <code>GravatarBlobRepository</code> como es nuestro caso. Además podríamos cambiar la implementación tanto en &quot;compilación&quot; como en caliente.</p>\n<p>Aquí está <code>GravatarBlobRepository</code>:</p>\n<pre><code class=\"language-typescript\">import { GravatarRepository } from './GravatarRepository'\nimport { User } from '../../users/User'\nimport { Fetcher } from '../../Fetcher'\n\nexport class GravatarBlobRepository implements GravatarRepository {\n    private url: string\n\n    constructor(private readonly fetcher: Fetcher) {\n        this.url = 'https://cors-anywhere.herokuapp.com/https://seccdn.libravatar.org/avatar'\n    }\n\n    async getUserByEmailHash(hash: string): Promise&lt;User&gt; {\n        const response = await this.fetcher(`${this.url}/${hash}`)\n        const result = await response.blob()\n        const object = URL.createObjectURL(result)\n        return new User(object)\n    }\n}\n</code></pre>\n<p>Por constructor le hemos pasado un <code>fetcher</code>, este es el encargado de recoger los datos de una API y tiene el siguiente tipo:</p>\n<pre><code class=\"language-typescript\">export type Fetcher = &lt;Response = any&gt;(\n    query: string,\n    options?: {\n        mode: string\n    }\n) =&gt; Promise&lt;{ json: () =&gt; Promise&lt;Response&gt;; blob: () =&gt; Promise&lt;Response&gt; }&gt;\n</code></pre>\n<p>A aquellos que les suene verá que es igualito que el API de <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API\">fetch</a>, que es el que usaremos luego en verdad.</p>\n<p>Y por último, ¿dónde creamos la instancia de <code>GravatarBlobRepository</code>? Pues con una factoría.</p>\n<p><code>GravataRepositoryFactory</code>:</p>\n<pre><code class=\"language-typescript\">import { GravatarRepository } from './GravatarRepository'\nimport { GravatarBlobRepository } from './GravatarBlobRepository'\nimport { Fetcher } from '../../Fetcher'\n\nexport class GravatarRepositoryFactory {\n    static photo(): GravatarRepository {\n        const fetcher = window.fetch.bind(window) as Fetcher\n        return new GravatarBlobRepository(fetcher)\n    }\n}\n</code></pre>\n<p>Aquí vemos que hemos pasado de una abstracción <code>Fetcher</code> a una concreción: <code>window.fetch</code>, siendo en un futuro configurable e intercambiable por otra solución.</p>\n<p>Por último hemos modelado nuestro usuario con una clase. Aquí tenemos el modelo del <code>User</code>:</p>\n<pre><code class=\"language-typescript\">export class User {\n    constructor(private readonly photo: string) {}\n\n    static empty() {\n        return new User('')\n    }\n\n    exists(): boolean {\n        return this.photo.length !== 0\n    }\n}\n</code></pre>\n<p>Es importante evitar que nuestros modelos sean interfaces sin comportamiento o clases con setters o propiedades públicas, ya que nos pueden llevar a <a href=\"https://www.martinfowler.com/bliki/AnemicDomainModel.html\">modelos anémicos</a>, es decir modelos que son una bolsa de propiedades, siendo imposible determinar cual es su estado válido, delegando en el consumidor la lógica de validez, lo que haría a su vez que duplicásemos esa lógica.</p>\n<h2>Conclusión</h2>\n<p>El front no es fácil. Venimos de un mundo dónde a lo más que podíamos aspirar es a maquetar, aplicar estilos y usar algo de JavaScript para lograr animaciones e interactividad con la página. Todo esto ha cambiado, ahora debemos gestionar un montón de estado, asincronía, optimización de peticiones y caché, diseño responsive, reactividad y un montón más de cosas.</p>\n<p>¿Por qué nos privamos de usar las herramientas y mecanismos que se llevan usando en la programación orientada a objetos desde hace más de 20 años que se han visto que funcionan?</p>\n<p>Sígueme en <a href=\"https://twitter.com/\">Twitter</a> y en <a href=\"https://github.com/cesalberca\">Github</a>.</p>\n",attributes:{title:"Haciendo (Vue)n frontend",date:"2019-03-29T00:00:00.000Z",locale:"es"}}},"4f44":function(e,t){},"5bd1":function(e,t,n){},6516:function(e,t){},"6e2d":function(e,t,n){"use strict";var o=n("1d7e"),a=n.n(o);a.a},"6e34":function(e,t,n){"use strict";var o=n("aaeb"),a=n.n(o);a.a},"6f17":function(e,t,n){"use strict";var o=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",[n("label",[e._v("\n    "+e._s(e.languageLabel)+"\n    "),n("select",{directives:[{name:"model",rawName:"v-model",value:e.locale,expression:"locale"}],on:{change:[function(t){var n=Array.prototype.filter.call(t.target.options,function(e){return e.selected}).map(function(e){var t="_value"in e?e._value:e.value;return t});e.locale=t.target.multiple?n:n[0]},function(t){return e.changeLocale(e.locale)}]}},e._l(e.locales,function(t){return n("option",{key:t.value,domProps:{value:t.value}},[e._v(e._s(t.text))])}),0)]),n("label",[e._v("\n    "+e._s(e.themeLabel)+"\n    "),n("select",{directives:[{name:"model",rawName:"v-model",value:e.theme,expression:"theme"}],on:{change:[function(t){var n=Array.prototype.filter.call(t.target.options,function(e){return e.selected}).map(function(e){var t="_value"in e?e._value:e.value;return t});e.theme=t.target.multiple?n:n[0]},function(t){return e.changeTheme(e.theme)}]}},e._l(e.themes,function(t){return n("option",{key:t.value,domProps:{value:t.value}},[e._v(e._s(t.text))])}),0)])])},a=[],r=n("d225"),s=n("b0b4"),i=n("308d"),c=n("6bb5"),u=n("4e2b"),l=n("9ab4"),p=n("60a3"),m=n("799f"),d=n("3507"),h=function(e){function t(){var e;return Object(r["a"])(this,t),e=Object(i["a"])(this,Object(c["a"])(t).apply(this,arguments)),e.theme=m["a"].DEFAULT,e.themes=[{text:e.light,value:m["a"].LIGHT},{text:e.dark,value:m["a"].DARK}],e.locale=d["a"].DEFAULT,e.locales=[{text:e.en,value:d["a"].EN},{text:e.es,value:d["a"].ES}],e}return Object(u["a"])(t,e),Object(s["a"])(t,[{key:"changeLocale",value:function(e){this.state.locale=e}},{key:"changeTheme",value:function(e){this.state.theme=e}},{key:"en",get:function(){return this.translationService.translate(this.state.locale,"_en")}},{key:"es",get:function(){return this.translationService.translate(this.state.locale,"_es")}},{key:"light",get:function(){return this.translationService.translate(this.state.locale,"_light")}},{key:"dark",get:function(){return this.translationService.translate(this.state.locale,"_dark")}},{key:"themeLabel",get:function(){return this.translationService.translate(this.state.locale,"_theme")}},{key:"languageLabel",get:function(){return this.translationService.translate(this.state.locale,"_language")}}]),t}(p["f"]);l["a"]([Object(p["c"])()],h.prototype,"state",void 0),l["a"]([Object(p["c"])()],h.prototype,"translationService",void 0),h=l["a"]([p["a"]],h);var v=h,f=v,g=(n("8b80"),n("2877")),y=Object(g["a"])(f,o,a,!1,null,"62c79858",null),b=y.exports,w=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("nav",{staticClass:"navbar"},[n("div",{staticClass:"links"},[n("router-link",{attrs:{to:"/"}},[e._v(e._s(e.translations.home))]),n("router-link",{attrs:{to:"/articles"}},[e._v(e._s(e.translations.articles))]),n("router-link",{attrs:{to:"/talks"}},[e._v(e._s(e.translations.talks))]),n("router-link",{attrs:{to:"/about"}},[e._v(e._s(e.translations.about))])],1),n("Options",{staticClass:"options"})],1)},q=[],k=function(e){function t(){return Object(r["a"])(this,t),Object(i["a"])(this,Object(c["a"])(t).apply(this,arguments))}return Object(u["a"])(t,e),Object(s["a"])(t,[{key:"translations",get:function(){return{home:this.translationService.translate(this.state.locale,"home_title"),about:this.translationService.translate(this.state.locale,"about_title"),talks:this.translationService.translate(this.state.locale,"talks_title"),articles:this.translationService.translate(this.state.locale,"article_title")}}}]),t}(p["f"]);l["a"]([Object(p["c"])()],k.prototype,"translationService",void 0),l["a"]([Object(p["c"])()],k.prototype,"state",void 0),k=l["a"]([Object(p["a"])({components:{Options:b}})],k);var j=k,C=j,U=(n("af94"),Object(g["a"])(C,w,q,!1,null,"04ce6b16",null)),E=U.exports,R=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{staticClass:"excerpt",attrs:{tabindex:"0"},on:{click:e.onClick}},[n("h3",[e._v(e._s(e.excerpt.title))]),n("span",{staticClass:"slugline"},[e._v(e._s(e.excerpt.date))]),n("p",{domProps:{innerHTML:e._s(e.excerpt.body)}})])},A=[],x=function(e){function t(){return Object(r["a"])(this,t),Object(i["a"])(this,Object(c["a"])(t).apply(this,arguments))}return Object(u["a"])(t,e),Object(s["a"])(t,[{key:"onClick",value:function(){return this.excerpt.id}}]),t}(p["f"]);l["a"]([Object(p["d"])()],x.prototype,"excerpt",void 0),l["a"]([Object(p["b"])()],x.prototype,"onClick",null),x=l["a"]([p["a"]],x);var O=x,P=O,_=(n("c2f3"),Object(g["a"])(P,R,A,!1,null,"5f6f0d5e",null)),F=_.exports,G=n("a57a");n.d(t,"c",function(){return b}),n.d(t,"b",function(){return E}),n.d(t,"a",function(){return F}),n.d(t,"d",function(){return G["a"]})},"771a":function(e,t,n){},"799f":function(e,t,n){"use strict";var o;n.d(t,"a",function(){return o}),function(e){e[e["LIGHT"]=0]="LIGHT",e[e["DARK"]=1]="DARK",e[e["DEFAULT"]=0]="DEFAULT"}(o||(o={}))},"7a89":function(e,t,n){"use strict";var o=n("b6ed"),a=n.n(o);a.a},"7f1a":function(e,t,n){},"82e5":function(e,t,n){"use strict";n.d(t,"a",function(){return i});var o=n("d225"),a=n("b0b4"),r=n("0e54"),s=n.n(r),i=function(){function e(t){Object(o["a"])(this,e),this._value=t}return Object(a["a"])(e,[{key:"toHtml",value:function(){return s()(this._value)}},{key:"value",get:function(){return this._value}}],[{key:"fromValue",value:function(t){return new e(t)}}]),e}()},"898a":function(e,t){function n(e){var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t}n.keys=function(){return[]},n.resolve=n,e.exports=n,n.id="898a"},"8b80":function(e,t,n){"use strict";var o=n("771a"),a=n.n(o);a.a},"9f8e":function(e,t,n){"use strict";var o=n("1bb4"),a=n("82e5"),r=(n("28a5"),n("d225")),s=n("b0b4"),i=function(){function e(t,n,o,a,s){Object(r["a"])(this,e),this.id=t,this.title=n,this.date=o,this.body=a,this.locale=s}return Object(s["a"])(e,[{key:"getExcerpt",value:function(){return{id:this.id,title:this.title,date:this.getFormattedDate(),body:this.getSummary(this.body.toHtml()),locale:this.locale}}},{key:"getFormattedDate",value:function(){return this.date.format()}},{key:"getSummary",value:function(t){return t.split(e.SUMMARY_SEPARATOR)[0]}}],[{key:"create",value:function(t){return new e(t.id,t.title,t.date,t.body,t.locale)}}]),e}();i.SUMMARY_SEPARATOR="\x3c!--more--\x3e";n("d64a");n.d(t,"b",function(){return o["a"]}),n.d(t,"c",function(){return a["a"]}),n.d(t,"a",function(){return i})},a37e:function(e,t,n){},a57a:function(e,t,n){"use strict";var o=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{staticClass:"page"},[n("div",{staticClass:"wrapper"},[e._t("default")],2)])},a=[],r=n("d225"),s=n("308d"),i=n("6bb5"),c=n("4e2b"),u=n("9ab4"),l=n("60a3"),p=function(e){function t(){return Object(r["a"])(this,t),Object(s["a"])(this,Object(i["a"])(t).apply(this,arguments))}return Object(c["a"])(t,e),t}(l["f"]);p=u["a"]([l["a"]],p);var m=p,d=m,h=(n("6e2d"),n("2877")),v=Object(h["a"])(d,o,a,!1,null,"a43d16f2",null);t["a"]=v.exports},a78d:function(e,t,n){var o={"./haciendo-vuen-frontend.md":"4e1d"};function a(e){var t=r(e);return n(t)}function r(e){var t=o[e];if(!(t+1)){var n=new Error("Cannot find module '"+e+"'");throw n.code="MODULE_NOT_FOUND",n}return t}a.keys=function(){return Object.keys(o)},a.resolve=r,e.exports=a,a.id="a78d"},aaeb:function(e,t,n){},af94:function(e,t,n){"use strict";var o=n("a37e"),a=n.n(o);a.a},b6ed:function(e,t,n){},b979:function(e,t,n){var o={"./en/haciendo-vuen-frontend.md":["4e1d"]};function a(e){var t=o[e];return t?Promise.all(t.slice(1).map(n.e)).then(function(){var e=t[0];return n.t(e,7)}):Promise.resolve().then(function(){var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t})}a.keys=function(){return Object.keys(o)},a.id="b979",e.exports=a},c23c:function(e,t,n){},c2f3:function(e,t,n){"use strict";var o=n("7f1a"),a=n.n(o);a.a},c655:function(e,t,n){"use strict";var o;n.d(t,"a",function(){return o}),function(e){e[e["EASY"]=0]="EASY",e[e["INTERMEDIATE"]=1]="INTERMEDIATE",e[e["ADVANCED"]=2]="ADVANCED"}(o||(o={}))},cd49:function(e,t,n){"use strict";n.r(t);n("cadf"),n("551c"),n("f751"),n("097d");var o=n("2b0e"),a=n("f79b"),r=n("d225"),s=n("b0b4"),i=n("9483"),c=function(){function e(t){Object(r["a"])(this,e),this.log=t}return Object(s["a"])(e,[{key:"register",value:function(){var e=this;Object(i["a"])("".concat("/blog/","service-worker.js"),{ready:function(){e.log("App is being served from cache by a service worker.\nFor more details, visit https://goo.gl/AFskqB")},registered:function(){e.log("Service worker has been registered.")},cached:function(){e.log("Content has been cached for offline use.")},updatefound:function(){e.log("New content is downloading.")},updated:function(){e.log("New content is available; please refresh.")},offline:function(){e.log("No internet connection found. App is running in offline mode.")},error:function(t){e.log("Error during service worker registration:",t)}})}}]),e}(),u=n("8c4f");new a["b"](o["default"],a["d"].create(u["a"]),new c(window.console.log)).bootstrap(a["a"])},d504:function(e,t,n){"use strict";var o,a=n("d225"),r=n("b0b4"),s=n("3507"),i=function(){function e(t){Object(a["a"])(this,e),this.translator=t}return Object(r["a"])(e,[{key:"translate",value:function(e,t){var n=this.translator.translations.get(e);if(void 0!==n){var o=n.get(t);if(void 0!==o)return o;var a=this.translator.getDefaultLocaleTranslation().get(t);if(void 0===a)throw new s["b"]('Translation for key "'.concat(t,'" in locale "').concat(e,'" could not be found'));return a}return this.translator.getDefaultLocaleTranslation().get(t)}},{key:"toString",value:function(e){switch(e){case s["a"].DEFAULT:case s["a"].EN:return"en";case s["a"].ES:return"es";default:throw new s["b"]("Locale ".concat(e," not found"))}}},{key:"toLocale",value:function(e){switch(e){case"en":return s["a"].EN;case"es":return s["a"].ES;default:throw new s["b"]("String ".concat(e," could not be mapped to a locale"))}}}],[{key:"create",value:function(t){return new e(t)}}]),e}(),c=(n("96cf"),n("3b8d")),u=function(){function e(t,n,o,r,s,i,c,u){Object(a["a"])(this,e),this.id=t,this.title=n,this.abstract=o,this.length=r,this.difficulty=s,this.language=i,this.topics=c,this.references=u}return Object(r["a"])(e,null,[{key:"create",value:function(t){return new e(t.id,t.title,t.abstract,t.length,t.difficulty,t.language,t.topics,t.references)}}]),e}(),l=n("1bb4");(function(e){e[e["SPANISH"]=0]="SPANISH",e[e["ENGLISH"]=1]="ENGLISH"})(o||(o={}));var p=n("c655"),m=function(){function e(t){Object(a["a"])(this,e),this._seconds=t}return Object(r["a"])(e,[{key:"seconds",get:function(){return this._seconds}},{key:"minutes",get:function(){return this._seconds/60}}],[{key:"fromMinutes",value:function(t){return new e(60*t)}}]),e}(),d=n("82e5"),h=function(){function e(){Object(a["a"])(this,e)}return Object(r["a"])(e,null,[{key:"getTalksGiven",value:function(){return[u.create({id:l["a"].fromValue("Advanced JavaScript Patterns"),title:"Advanced JavaScript Patterns",topics:[],language:o.ENGLISH,difficulty:p["a"].ADVANCED,length:m.fromMinutes(45),references:[],abstract:d["a"].fromValue("When you tell people you code in JavaScript they usually look down on you. This talk will give you the tools to enlighten those heretics. We'll be entering the world of **design patterns** applied to JavaScript, looking through some of the cutting edge properties of ES6 such as **Proxies** and **default function parameter expressions**, dealing with **objects** and even some examples of **functional programming**. This talk is not allowed for cardiacs.")})]}}]),e}(),v=function(){function e(){Object(a["a"])(this,e)}return Object(r["a"])(e,[{key:"execute",value:function(){var e=Object(c["a"])(regeneratorRuntime.mark(function e(){return regeneratorRuntime.wrap(function(e){while(1)switch(e.prev=e.next){case 0:return e.abrupt("return",h.getTalksGiven());case 1:case"end":return e.stop()}},e)}));function t(){return e.apply(this,arguments)}return t}()}]),e}(),f=function(){function e(t,n,o){Object(a["a"])(this,e),this.articlesRepository=t,this.id=n,this.locale=o}return Object(r["a"])(e,[{key:"execute",value:function(){var e=Object(c["a"])(regeneratorRuntime.mark(function e(){return regeneratorRuntime.wrap(function(e){while(1)switch(e.prev=e.next){case 0:return e.abrupt("return",this.articlesRepository.findOneByLocale(this.id,this.locale));case 1:case"end":return e.stop()}},e,this)}));function t(){return e.apply(this,arguments)}return t}()}]),e}(),g=function(){function e(t,n){Object(a["a"])(this,e),this.articlesRepository=t,this.locale=n}return Object(r["a"])(e,[{key:"execute",value:function(){var e=Object(c["a"])(regeneratorRuntime.mark(function e(){return regeneratorRuntime.wrap(function(e){while(1)switch(e.prev=e.next){case 0:return e.abrupt("return",this.articlesRepository.findAllByLocale(this.locale));case 1:case"end":return e.stop()}},e,this)}));function t(){return e.apply(this,arguments)}return t}()}]),e}(),y=n("795b"),b=n.n(y),w=(n("ac6a"),n("5df3"),n("6b54"),n("9f8e")),q=function(){function e(t){Object(a["a"])(this,e),this._value=t}return Object(r["a"])(e,[{key:"format",value:function(){return this._value.toLocaleDateString(void 0,{day:"numeric",month:"long",year:"numeric"})}},{key:"value",get:function(){return this._value}}],[{key:"fromString",value:function(t){return new e(new Date(t))}},{key:"fromDate",value:function(t){return new e(t)}},{key:"fromNow",value:function(){return new e(new Date)}}]),e}(),k=function(){function e(t,n){Object(a["a"])(this,e),this.fileLoader=t,this.translationService=n}return Object(r["a"])(e,[{key:"findOneByLocale",value:function(){var e=Object(c["a"])(regeneratorRuntime.mark(function e(t,o){var a,r;return regeneratorRuntime.wrap(function(e){while(1)switch(e.prev=e.next){case 0:return e.prev=0,e.next=3,n("b979")("./".concat(this.translationService.toString(o),"/").concat(t.value,".md"));case 3:a=e.sent,e.next=12;break;case 6:return e.prev=6,e.t0=e["catch"](0),r=this.translationService.toString(s["a"].DEFAULT),e.next=11,n("b979")("./".concat(r,"/").concat(t.value,".md"));case 11:a=e.sent;case 12:return e.abrupt("return",w["a"].create({id:t,body:w["c"].fromValue(a.body),date:q.fromString(a.attributes.date),title:a.attributes.title,locale:this.translationService.toLocale(a.attributes.locale)}));case 13:case"end":return e.stop()}},e,this,[[0,6]])}));function t(t,n){return e.apply(this,arguments)}return t}()},{key:"findAllByLocale",value:function(){var e=Object(c["a"])(regeneratorRuntime.mark(function e(t){var n,o=this;return regeneratorRuntime.wrap(function(e){while(1)switch(e.prev=e.next){case 0:return n=this.fileLoader.loadArticles().map(function(e){return e.substr(2,e.length).substr(0,e.length-5)}),e.abrupt("return",b.a.all(n.map(function(e){return o.findOneByLocale(w["b"].fromValue(e),t)})));case 2:case"end":return e.stop()}},e,this)}));function t(t){return e.apply(this,arguments)}return t}()}]),e}(),j=n("75fc"),C=n("b6d0"),U=n.n(C),E=n("774e"),R=n.n(E),A=function(){function e(){Object(a["a"])(this,e)}return Object(r["a"])(e,[{key:"loadArticles",value:function(){var e=n("898a").keys(),t=n("a78d").keys();return R()(new U.a([].concat(Object(j["a"])(e),Object(j["a"])(t))))}}],[{key:"create",value:function(){return new e}}]),e}(),x=function(){function e(){Object(a["a"])(this,e)}return Object(r["a"])(e,null,[{key:"get",value:function(e,t){switch(e){case"GetAllArticles":return new g(new k(A.create(),i.create(s["c"].create())),t.locale);case"GetTalksGiven":return new v;case"GetArticle":return new f(new k(A.create(),i.create(s["c"].create())),t.id,t.locale);default:throw new Error('Use case "'.concat(e,'" not found'))}}}]),e}();n.d(t,"a",function(){return i}),n.d(t,"b",function(){return x})},d64a:function(e,t){},d663:function(e,t,n){"use strict";var o=n("d225"),a=n("3507"),r=n("799f"),s=function e(){Object(o["a"])(this,e),this.locale=a["a"].DEFAULT,this.theme=r["a"].DEFAULT},i=n("b0b4"),c=(n("ac6a"),n("d3d7")),u=n.n(c),l=function(){function e(){var t=this;Object(o["a"])(this,e),this.observers=[],this.state=new Proxy(new s,{set:function(e,n,o,a){return u()(e,n,o,a),t.notifyAll(),!0}})}return Object(i["a"])(e,[{key:"notifyAll",value:function(){this.observers.forEach(function(e){return e.notify()})}},{key:"register",value:function(e){this.observers.push(e)}}]),e}(),p=function(){function e(){Object(o["a"])(this,e),this._state=new s}return Object(i["a"])(e,[{key:"create",value:function(e){var t=new l,n=t.state;return this._state=e.observable(n),this}},{key:"state",get:function(){return this._state}}],[{key:"instance",get:function(){return null===this._instance&&(this._instance=new e),this._instance}}]),e}();p._instance=null,n.d(t,"a",function(){return p})},f79b:function(e,t,n){"use strict";var o=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",[e._t("default")],2)},a=[],r=n("d225"),s=n("308d"),i=n("6bb5"),c=n("4e2b"),u=n("9ab4"),l=n("60a3"),p=n("d663"),m=n("d504"),d=n("3507"),h=function(e){function t(){var e;return Object(r["a"])(this,t),e=Object(s["a"])(this,Object(i["a"])(t).apply(this,arguments)),e.translationService=m["a"].create(d["c"].create()),e.state=p["a"].instance.create(l["f"]).state,e}return Object(c["a"])(t,e),t}(l["f"]);u["a"]([Object(l["e"])()],h.prototype,"translationService",void 0),u["a"]([Object(l["e"])()],h.prototype,"state",void 0),h=u["a"]([l["a"]],h);var v=h,f=v,g=n("2877"),y=Object(g["a"])(f,o,a,!1,null,null,null),b=y.exports,w=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("main",[n("Injector",[n("Theming",{staticClass:"full-height"},[n("Navbar"),n("Page",[n("router-view")],1)],1)],1)],1)},q=[],k=n("6f17"),j=n("a57a"),C=function(){var e,t=this,n=t.$createElement,o=t._self._c||n;return o("div",{class:(e={},e[t.theme]=!0,e)},[t._t("default")],2)},U=[],E=n("b0b4"),R=n("799f"),A=function(e){function t(){return Object(r["a"])(this,t),Object(s["a"])(this,Object(i["a"])(t).apply(this,arguments))}return Object(c["a"])(t,e),Object(E["a"])(t,[{key:"theme",get:function(){switch(this.state.theme){case R["a"].DARK:return"dark";case R["a"].LIGHT:default:return"light"}}}]),t}(l["f"]);u["a"]([Object(l["c"])()],A.prototype,"state",void 0),A=u["a"]([l["a"]],A);var x=A,O=x,P=(n("7a89"),Object(g["a"])(O,C,U,!1,null,"130a28be",null)),_=P.exports,F=function(e){function t(){return Object(r["a"])(this,t),Object(s["a"])(this,Object(i["a"])(t).apply(this,arguments))}return Object(c["a"])(t,e),t}(l["f"]);F=u["a"]([Object(l["a"])({components:{Page:j["a"],Injector:b,Navbar:k["b"],Theming:_}})],F);var G=F,S=G,V=(n("6e34"),Object(g["a"])(S,w,q,!1,null,"68dc479c",null)),T=V.exports,I=(n("33e6"),n("091c"),n("c23c"),n("5bd1"),n("1f48"),n("8c4f")),D=function(){function e(t,n,o){Object(r["a"])(this,e),this.vue=t,this.router=n,this.serviceWorker=o}return Object(E["a"])(e,[{key:"bootstrap",value:function(e){this.vue.use(I["a"]),this.vue.config.productionTip=!1,this.serviceWorker.register(),new this.vue({router:this.router.value,render:function(t){return t(e)}}).$mount("#app")}}]),e}(),L=function(){function e(t){Object(r["a"])(this,e),this.vueRouter=t,this._value=new this.vueRouter({mode:"history",base:"/blog/",routes:[{path:"/",name:"home",component:function(){return n.e("home").then(n.bind(null,"35fa"))}},{path:"/articles",name:"articles",component:function(){return n.e("articles").then(n.bind(null,"1003"))}},{path:"/article/:id",name:"article",component:function(){return n.e("articles").then(n.bind(null,"daf0"))}},{path:"/about",name:"about",component:function(){return n.e("about").then(n.bind(null,"1ac5"))}},{path:"/talks",name:"talks",component:function(){return n.e("talks").then(n.bind(null,"d566"))}}]})}return Object(E["a"])(e,[{key:"value",get:function(){return this._value}}],[{key:"create",value:function(t){return new e(t)}}]),e}();n.d(t,"c",function(){return b}),n.d(t,"a",function(){return T}),n.d(t,"b",function(){return D}),n.d(t,"d",function(){return L})}});
//# sourceMappingURL=app.bffb3106.js.map